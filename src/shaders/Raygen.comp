#version 460 core

layout(binding = 0, std140) uniform ProjectionProperties
{
	mat4 View;
	mat4 ViewInv;
	mat4 Proj;
	mat4 ProjInv;
} u_projectionProperties;

layout(binding = 1, std140) uniform ScreenProperties
{
	uvec2 Size;
} u_screenProperties;

layout(binding = 0, std430) buffer VoxelDataStorage
{
	uint VoxelData[32 * 32 * 32];
};

layout(binding = 0, rgba32f) uniform image2D u_renderedImage;

struct RayHitInfo
{
	float Distance;
	vec3 Normal;
	vec3 Point;
};

// x -> Distance to the nearest intersection.
// y -> Distance to the furthest intersection.
vec2 RayBoxIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax)
{
	vec3 rayDirectionInverse = vec3(1.0) / rayDirection;

	vec2 tx = (vec2(boundsMin.x, boundsMax.x) - vec2(rayOrigin.x)) * rayDirectionInverse.x;
	vec2 ty = (vec2(boundsMin.y, boundsMax.y) - vec2(rayOrigin.y)) * rayDirectionInverse.y;
	vec2 tz = (vec2(boundsMin.z, boundsMax.z) - vec2(rayOrigin.z)) * rayDirectionInverse.z;

	float tmin = max(max(min(tx.x, tx.y), min(ty.x, ty.y)), min(tz.x, tz.y));
	float tmax = min(min(max(tx.x, tx.y), max(ty.x, ty.y)), max(tz.x, tz.y));

	// Box behind
	if(tmax < 0.0)
	{
		return vec2(-1.0);
	}

	// Doesnt't intersect
	if(tmin > tmax)
	{
		return vec2(-1.0);
	}
	
	// Ray inside box
	if(tmin < 0.0)
	{
		return vec2(0.0, tmax);
	}

	return vec2(tmin, tmax);
}

bool GetVoxel(ivec3 position)
{
	position.z += 32;
	position.y += 16;

	if(position.x < 0 || position.x >= 32 || position.y < 0 || position.y >= 32 || position.z < 0 || position.z >= 32)
	{
		return false;
	}

	return VoxelData[position.y * 32 * 32 + position.z * 32 + position.x] > 0;
}

bool RayVoxelIntersection(vec3 rayOrigin, vec3 rayDirection, float maxDistance, out RayHitInfo hitInfo)
{
	vec3 stepSize = abs(1.0 / rayDirection);

	ivec3 mapPosition = ivec3(floor(rayOrigin));
	ivec3 stepDirection = ivec3(sign(rayDirection));

	vec3 rayLength = abs((mapPosition + max(stepDirection, vec3(0.0)) - rayOrigin) * stepSize);

	hitInfo.Distance = 0.0;
	while(hitInfo.Distance < maxDistance)
	{
		if(rayLength.x < rayLength.y)
		{
			if(rayLength.x < rayLength.z)
			{
				mapPosition.x += stepDirection.x;
				hitInfo.Distance = rayLength.x;
				rayLength.x += stepSize.x;

				hitInfo.Normal = vec3(-stepDirection.x, 0.0, 0.0);
			}
			else
			{
				mapPosition.z += stepDirection.z;
				hitInfo.Distance = rayLength.z;
				rayLength.z += stepSize.z;

				hitInfo.Normal = vec3(0.0, 0.0, -stepDirection.z);
			}
		}
		else
		{
			if(rayLength.y < rayLength.z)
			{
				mapPosition.y += stepDirection.y;
				hitInfo.Distance = rayLength.y;
				rayLength.y += stepSize.y;

				hitInfo.Normal = vec3(0.0, -stepDirection.y, 0.0);
			}
			else
			{
				mapPosition.z += stepDirection.z;
				hitInfo.Distance = rayLength.z;
				rayLength.z += stepSize.z;

				hitInfo.Normal = vec3(0.0, 0.0, -stepDirection.z);
			}
		}

		if(GetVoxel(mapPosition))
		{
			hitInfo.Point = rayOrigin + hitInfo.Distance * rayDirection;
			return true;
		}
	}

	return false;
}

vec3 GetRayDirection(vec2 uv)
{
	uv = uv * 2.0 - 1.0;

	vec4 pointNDSH = vec4(uv, -1.0, 1.0);

	vec4 eyeDir = u_projectionProperties.ProjInv * pointNDSH;
	eyeDir.w = 0.0;

	vec3 worldDir = (u_projectionProperties.ViewInv * eyeDir).xyz;

	return normalize(worldDir);
}

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main()
{
	const vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(u_screenProperties.Size);
	const vec3 rayOrigin = u_projectionProperties.ViewInv[3].xyz;
	const vec3 rayDirection = GetRayDirection(uv);

	const vec3 lightDirection = normalize(vec3(-2.0, -4.0, 2.0));

	vec3 color = vec3(0.0, 0.0, 0.0);
	color = rayDirection;

	for(uint i = 0; i < 4; i++)
	{
		color = GetRayDirection(uv);
	}

	RayHitInfo hitInfo;
	if(RayVoxelIntersection(rayOrigin, rayDirection, 256.0, hitInfo))
	{
		float lightStrength = 0.1;

		RayHitInfo shadowHitInfo;
		if(!RayVoxelIntersection(hitInfo.Point + hitInfo.Normal * 0.01, -lightDirection, 64.0, shadowHitInfo))
		{
			lightStrength += clamp(dot(hitInfo.Normal, -lightDirection), 0.0, 1.0) * 2.0;
		}

		color = vec3(lightStrength);
	}

	imageStore(u_renderedImage, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));
}
